package apply

import (
	"context"
	"errors"
	"fmt"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

func TestRetryManager_ExecuteWithRetry_Success(t *testing.T) {
	config := DefaultRetryConfig()
	rm := NewRetryManager(config)

	operation := &PlannedOperation{
		Operation: Operation{
			Type: OperationCreate,
		},
		ID: "test-op-1",
	}

	callCount := 0
	err := rm.ExecuteWithRetry(context.Background(), operation, func() error {
		callCount++
		return nil
	})

	assert.NoError(t, err)
	assert.Equal(t, 1, callCount)
	assert.Equal(t, 0, rm.GetRetryCount(operation.ID))
}

func TestRetryManager_ExecuteWithRetry_RetryableError(t *testing.T) {
	config := DefaultRetryConfig()
	config.MaxRetries = 2
	rm := NewRetryManager(config)

	operation := &PlannedOperation{
		Operation: Operation{
			Type: OperationCreate,
		},
		ID: "test-op-2",
	}

	callCount := 0
	err := rm.ExecuteWithRetry(context.Background(), operation, func() error {
		callCount++
		if callCount < 3 {
			return errors.New("rate limit exceeded")
		}
		return nil
	})

	assert.NoError(t, err)
	assert.Equal(t, 3, callCount)
	assert.Equal(t, 2, rm.GetRetryCount(operation.ID))
}

func TestRetryManager_ExecuteWithRetry_NonRetryableError(t *testing.T) {
	config := DefaultRetryConfig()
	rm := NewRetryManager(config)

	operation := &PlannedOperation{
		Operation: Operation{
			Type: OperationCreate,
		},
		ID: "test-op-3",
	}

	callCount := 0
	err := rm.ExecuteWithRetry(context.Background(), operation, func() error {
		callCount++
		return errors.New("unauthorized")
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "non-retryable error")
	assert.Equal(t, 1, callCount)
	assert.Equal(t, 1, rm.GetRetryCount(operation.ID))
}

func TestRetryManager_ExecuteWithRetry_MaxRetriesExceeded(t *testing.T) {
	config := DefaultRetryConfig()
	config.MaxRetries = 2
	rm := NewRetryManager(config)

	operation := &PlannedOperation{
		Operation: Operation{
			Type: OperationCreate,
		},
		ID: "test-op-4",
	}

	callCount := 0
	err := rm.ExecuteWithRetry(context.Background(), operation, func() error {
		callCount++
		return errors.New("timeout")
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "operation failed after 2 retries")
	assert.Equal(t, 3, callCount) // Initial attempt + 2 retries
	assert.Equal(t, 3, rm.GetRetryCount(operation.ID))
}

func TestRetryManager_ExecuteWithRetry_ContextCancellation(t *testing.T) {
	config := DefaultRetryConfig()
	config.InitialDelay = 100 * time.Millisecond
	rm := NewRetryManager(config)

	operation := &PlannedOperation{
		Operation: Operation{
			Type: OperationCreate,
		},
		ID: "test-op-5",
	}

	ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
	defer cancel()

	callCount := 0
	err := rm.ExecuteWithRetry(ctx, operation, func() error {
		callCount++
		return errors.New("timeout")
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "retry cancelled")
	assert.Equal(t, 1, callCount) // Should not retry due to context cancellation
}

func TestRetryManager_OperationSpecificPolicies(t *testing.T) {
	config := DefaultRetryConfig()

	// Set different retry limits for different operation types
	config.OperationPolicies[OperationCreate] = OperationRetryPolicy{
		MaxRetries:        5,
		InitialDelay:      1 * time.Millisecond,
		MaxDelay:          10 * time.Millisecond,
		BackoffMultiplier: 2.0,
		Enabled:           true,
	}
	config.OperationPolicies[OperationDelete] = OperationRetryPolicy{
		MaxRetries:        1,
		InitialDelay:      1 * time.Millisecond,
		MaxDelay:          5 * time.Millisecond,
		BackoffMultiplier: 1.5,
		Enabled:           true,
	}

	rm := NewRetryManager(config)

	// Test create operation with higher retry limit
	createOp := &PlannedOperation{
		Operation: Operation{Type: OperationCreate},
		ID:        "create-op",
	}

	createCallCount := 0
	err := rm.ExecuteWithRetry(context.Background(), createOp, func() error {
		createCallCount++
		return errors.New("timeout")
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "operation failed after 5 retries")
	assert.Equal(t, 6, createCallCount) // Initial + 5 retries

	// Test delete operation with lower retry limit
	deleteOp := &PlannedOperation{
		Operation: Operation{Type: OperationDelete},
		ID:        "delete-op",
	}

	deleteCallCount := 0
	err = rm.ExecuteWithRetry(context.Background(), deleteOp, func() error {
		deleteCallCount++
		return errors.New("timeout")
	})

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "operation failed after 1 retries")
	assert.Equal(t, 2, deleteCallCount) // Initial + 1 retry
}

func TestRetryManager_CalculateDelay(t *testing.T) {
	config := DefaultRetryConfig()
	config.Jitter = 0 // Disable jitter for predictable testing
	rm := NewRetryManager(config)

	policy := OperationRetryPolicy{
		InitialDelay:      1 * time.Second,
		MaxDelay:          10 * time.Second,
		BackoffMultiplier: 2.0,
	}

	tests := []struct {
		attempt  int
		expected time.Duration
	}{
		{0, 1 * time.Second},
		{1, 2 * time.Second},
		{2, 4 * time.Second},
		{3, 8 * time.Second},
		{4, 10 * time.Second}, // Capped at max delay
		{5, 10 * time.Second}, // Still capped
	}

	for _, tt := range tests {
		actual := rm.calculateDelay(tt.attempt, policy)
		assert.Equal(t, tt.expected, actual, "Attempt %d", tt.attempt)
	}
}

func TestRetryManager_IsRetryableError(t *testing.T) {
	config := DefaultRetryConfig()
	rm := NewRetryManager(config)

	tests := []struct {
		name      string
		error     error
		retryable bool
	}{
		{"timeout error", errors.New("timeout occurred"), true},
		{"rate limit error", errors.New("rate limit exceeded"), true},
		{"service unavailable", errors.New("service unavailable"), true},
		{"unauthorized error", errors.New("unauthorized access"), false},
		{"not found error", errors.New("resource not found"), false},
		{"conflict error", errors.New("resource conflict"), false},
		{"malformed request", errors.New("malformed request"), false},
		{"unknown error", errors.New("something went wrong"), false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			actual := rm.isRetryableError(tt.error)
			assert.Equal(t, tt.retryable, actual)
		})
	}
}

// Circuit Breaker Tests

func TestCircuitBreaker_ClosedState(t *testing.T) {
	config := CircuitBreakerConfig{
		Enabled:          true,
		FailureThreshold: 3,
		RecoveryTimeout:  1 * time.Second,
		SuccessThreshold: 2,
	}

	cb := NewCircuitBreaker(config)

	// Initially closed and should allow execution
	assert.True(t, cb.CanExecute())
	assert.Equal(t, CircuitBreakerClosed, cb.GetState())

	// Record some successes - should remain closed
	cb.RecordSuccess()
	cb.RecordSuccess()
	assert.True(t, cb.CanExecute())
	assert.Equal(t, CircuitBreakerClosed, cb.GetState())
}

func TestCircuitBreaker_OpenState(t *testing.T) {
	config := CircuitBreakerConfig{
		Enabled:          true,
		FailureThreshold: 3,
		RecoveryTimeout:  100 * time.Millisecond,
		SuccessThreshold: 2,
	}

	cb := NewCircuitBreaker(config)

	// Record failures to trigger opening
	cb.RecordFailure()
	cb.RecordFailure()
	assert.True(t, cb.CanExecute()) // Still closed

	cb.RecordFailure() // Should trigger open state
	assert.False(t, cb.CanExecute())
	assert.Equal(t, CircuitBreakerOpen, cb.GetState())

	// Wait for recovery timeout
	time.Sleep(150 * time.Millisecond)

	// Should transition to half-open
	assert.True(t, cb.CanExecute())
	assert.Equal(t, CircuitBreakerHalfOpen, cb.GetState())
}

func TestCircuitBreaker_HalfOpenState(t *testing.T) {
	config := CircuitBreakerConfig{
		Enabled:          true,
		FailureThreshold: 2,
		RecoveryTimeout:  10 * time.Millisecond,
		SuccessThreshold: 2,
	}

	cb := NewCircuitBreaker(config)

	// Trigger open state
	cb.RecordFailure()
	cb.RecordFailure()
	assert.Equal(t, CircuitBreakerOpen, cb.GetState())

	// Wait for recovery timeout
	time.Sleep(20 * time.Millisecond)

	// Should be half-open now
	assert.True(t, cb.CanExecute())
	assert.Equal(t, CircuitBreakerHalfOpen, cb.GetState())

	// Record success to move toward closed
	cb.RecordSuccess()
	assert.Equal(t, CircuitBreakerHalfOpen, cb.GetState())

	// Another success should close the circuit
	cb.RecordSuccess()
	assert.Equal(t, CircuitBreakerClosed, cb.GetState())
}

func TestCircuitBreaker_HalfOpenToOpen(t *testing.T) {
	config := CircuitBreakerConfig{
		Enabled:          true,
		FailureThreshold: 2,
		RecoveryTimeout:  10 * time.Millisecond,
		SuccessThreshold: 2,
	}

	cb := NewCircuitBreaker(config)

	// Trigger open state
	cb.RecordFailure()
	cb.RecordFailure()
	assert.Equal(t, CircuitBreakerOpen, cb.GetState())

	// Wait for recovery timeout
	time.Sleep(20 * time.Millisecond)

	// Should be half-open now
	assert.True(t, cb.CanExecute())
	assert.Equal(t, CircuitBreakerHalfOpen, cb.GetState())

	// Record failure - should go back to open
	cb.RecordFailure()
	assert.Equal(t, CircuitBreakerOpen, cb.GetState())
	assert.False(t, cb.CanExecute())
}

func TestCircuitBreaker_Stats(t *testing.T) {
	config := CircuitBreakerConfig{
		Enabled:          true,
		FailureThreshold: 3,
		RecoveryTimeout:  1 * time.Second,
		SuccessThreshold: 2,
	}

	cb := NewCircuitBreaker(config)

	// Record some operations
	cb.RecordSuccess()
	cb.RecordSuccess()
	cb.RecordFailure()
	cb.RecordFailure()

	stats := cb.GetStats()
	assert.Equal(t, CircuitBreakerClosed, stats.State)
	assert.Equal(t, 2, stats.Successes)
	assert.Equal(t, 2, stats.Failures)
	assert.Equal(t, 2, stats.ConsecutiveFailures)
	assert.False(t, stats.LastFailureTime.IsZero())
}

func TestRetryManager_CircuitBreakerIntegration(t *testing.T) {
	config := DefaultRetryConfig()
	config.CircuitBreakerConfig = CircuitBreakerConfig{
		Enabled:          true,
		FailureThreshold: 2,
		RecoveryTimeout:  50 * time.Millisecond,
		SuccessThreshold: 1,
	}
	rm := NewRetryManager(config)

	operation := &PlannedOperation{
		Operation: Operation{
			Type:         OperationCreate,
			ResourceType: "test",
		},
		ID: "circuit-test",
	}

	// First failure - should retry
	err := rm.ExecuteWithRetry(context.Background(), operation, func() error {
		return errors.New("timeout")
	})
	assert.Error(t, err)

	// Second failure - should trigger circuit breaker
	err = rm.ExecuteWithRetry(context.Background(), operation, func() error {
		return errors.New("timeout")
	})
	assert.Error(t, err)

	// Third attempt - should be blocked by circuit breaker
	err = rm.ExecuteWithRetry(context.Background(), operation, func() error {
		return errors.New("timeout")
	})
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "circuit breaker is open")
}

// Benchmark tests for performance validation

func BenchmarkRetryManager_ExecuteWithRetry_Success(b *testing.B) {
	config := DefaultRetryConfig()
	rm := NewRetryManager(config)

	operation := &PlannedOperation{
		Operation: Operation{Type: OperationCreate},
		ID:        "bench-op",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_ = rm.ExecuteWithRetry(context.Background(), operation, func() error {
			return nil
		})
	}
}

func BenchmarkRetryManager_ExecuteWithRetry_WithRetries(b *testing.B) {
	config := DefaultRetryConfig()
	config.MaxRetries = 2
	config.InitialDelay = 1 * time.Microsecond
	rm := NewRetryManager(config)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		operation := &PlannedOperation{
			Operation: Operation{Type: OperationCreate},
			ID:        fmt.Sprintf("bench-op-%d", i),
		}

		callCount := 0
		_ = rm.ExecuteWithRetry(context.Background(), operation, func() error {
			callCount++
			if callCount < 3 {
				return errors.New("timeout")
			}
			return nil
		})
	}
}

func TestDefaultRetryConfig(t *testing.T) {
	config := DefaultRetryConfig()

	// Validate default values
	assert.Equal(t, 3, config.MaxRetries)
	assert.Equal(t, 1*time.Second, config.InitialDelay)
	assert.Equal(t, 30*time.Second, config.MaxDelay)
	assert.Equal(t, 2.0, config.BackoffMultiplier)
	assert.Equal(t, 0.1, config.Jitter)

	// Validate operation-specific policies exist
	assert.Contains(t, config.OperationPolicies, OperationCreate)
	assert.Contains(t, config.OperationPolicies, OperationUpdate)
	assert.Contains(t, config.OperationPolicies, OperationDelete)

	// Validate circuit breaker config
	assert.True(t, config.CircuitBreakerConfig.Enabled)
	assert.Equal(t, 5, config.CircuitBreakerConfig.FailureThreshold)
	assert.Equal(t, 60*time.Second, config.CircuitBreakerConfig.RecoveryTimeout)

	// Validate error lists
	assert.Contains(t, config.RetryableErrors, "timeout")
	assert.Contains(t, config.RetryableErrors, "rate limit")
	assert.Contains(t, config.FatalErrors, "unauthorized")
	assert.Contains(t, config.FatalErrors, "not found")
}
